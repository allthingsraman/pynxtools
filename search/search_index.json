{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"FAIRmat NeXus documentation","text":"Project and community <p>The work is funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) - 460197019 (FAIRmat).</p>"},{"location":"index.html#tutorial","title":"Tutorial","text":"<p>A series of tutorials giving you an overview on how to store or convert your data to NeXus compliant files.</p> <ul> <li>Converting your data to NeXus</li> <li>Uploading NeXus data to NOMAD</li> </ul>"},{"location":"index.html#how-to-guides","title":"How-to guides","text":"<p>How-to guides provide step-by-step instructions for a wide range of tasks:</p> <ul> <li>Writing an application definition</li> <li>Storing data in multiple application definitions</li> <li>Representing experimental geometries</li> <li>Using pynxtools test framework</li> </ul>"},{"location":"index.html#learn","title":"Learn","text":"<p>An introduction to NeXus and its design principles.</p> <ul> <li>An introduction to NeXus</li> <li>The concept of multiple application definitions</li> </ul>"},{"location":"index.html#reference","title":"Reference","text":"<p>Within FAIRmat, we maintain a number of reader plugins for different experimental techniques. You can find more information here.</p> <p>Here, you find the detailed list of application definitions and base classes and their respective fields.</p> <p>Or go directly to the official NIAC  or latest FAIRmat definitions.</p>"},{"location":"how-tos/transformations.html","title":"Storing experimental geometries","text":"<p>Work in progress</p> <p>This part of the documentation is still being written and it might be confusing or incomplete.</p>"},{"location":"how-tos/using-multiple-appdefs.html","title":"Storing data following multiple appdefs","text":"<p>Work in progress</p> <p>This part of the documentation is still being written and it might be confusing or incomplete.</p>"},{"location":"how-tos/using-pynxtools-test-framework.html","title":"Generalized Test Functionality for <code>pynxtools</code> plugins","text":"<p>The <code>pynxtools</code> sub-package <code>testing</code> is to be utilized to write automated tests for pynxtools reader plugins without requiring in-depth knowledge of the pynxtools internal architecture. The tool supports generalised a general test for all reader plugins, irrespective of the technical details of the raw data files and the internal design of the plugin (note: it is assumed that the plugin was built from the plugin template or has the same structure internally).</p>"},{"location":"how-tos/using-pynxtools-test-framework.html#why-it-is-needed","title":"Why it is needed","text":"<p>To test integration of a plugin with the <code>pynxtools</code> core system, we need to: 1. Test the plugin's integration with <code>pynxtools</code> from the plugin's CI/CD. 2. Test in the pynxtools's CI/CD if the plugin has been integrated with <code>pynxtools</code> properly.</p>"},{"location":"how-tos/using-pynxtools-test-framework.html#how-to-write-an-integration-test-for-a-reader-plugin-with-pynxtoolstesting","title":"How to write an integration test for a reader plugin with <code>pynxtools.testing</code>","text":"<p>It is very simple to write a test to verify the plugin integration with <code>pynxtools</code> within the plugin's tests directory. The developer can place the test where they want, but they need to use the provided test interface from <code>pynxtools</code>. An example test for <code>pynxtools-FOO</code> (a demo plugin) plugin is given below:</p> <pre><code># test_plugin.py\n\nimport os\n\nimport pytest\nfrom pynxtools.testing.nexus_conversion import ReaderTest\n\n# e.g. module_dir = /pynxtools-foo/tests\nmodule_dir = os.path.dirname(os.path.abspath(__file__))\n\n\n@pytest.mark.parametrize(\n    \"nxdl,reader_name,files_or_dir\",\n    [\n        (\"NXfoo\", \"foo\", f\"{module_dir}/../tests/data/test_data_dir_1\"),\n        (\"NXfoo\", \"foo\", f\"{module_dir}/../tests/data/test_data_dir_2\")\n    ],\n)\ndef test_foo_reader(nxdl, reader_name, files_or_dir, tmp_path, caplog):\n    \"\"\"Test for the FooReader or foo reader plugin.\n\n    Parameters\n    ----------\n    nxdl : str\n        Name of the NXDL application definition that is to be tested by\n        this reader plugin (e.g. NXfoo), without the file ending .nxdl.xml.\n    reader_name : str\n        Name of the class of the reader (e.g. \"foo\")\n    files_or_dir : class\n        Name of the class of the reader.\n    tmp_path : pytest.fixture\n        Pytest fixture variable, used to create temporary file and clean up the generated files\n        after test.\n    caplog : pytest.fixture\n        Pytest fixture variable, used to capture the log messages during the test.\n    \"\"\"\n    # test plugin reader\n    test = ReaderTest(nxdl, reader_name, files_or_dir, tmp_path, caplog)\n    test.convert_to_nexus()\n    # test.convert_to_nexus(caplog_level=\"ERROR\", ignore_undocumented=True)\n    # Use `ignore_undocumented` to skip undocumented fields\n    # caplog_level can be \"ERROR\" or \"WARNING\"\n    test.check_reproducibility_of_nexus()\n</code></pre> <p>Alongside the test data in <code>test/data</code>, it is also possible to add other types of test data inside the test directory of the plugin.</p> <p>You can also pass additional parameters to <code>test.convert_to_nexus</code>:</p> <ul> <li> <p><code>caplog_level</code> (str): Can be either \"ERROR\" (by default) or \"warning\". This parameter determines the level at which the caplog is set during testing. If it is \"WARNING\", the test will also fail if any warnings are reported by the reader.</p> </li> <li> <p><code>ignore_undocumented</code> (boolean): If true, the test skipts the verification of undocumented keys. Otherwise, a warning massages for undocumented keys is raised</p> </li> </ul>"},{"location":"how-tos/writing-an-appdef.html","title":"Writing a Simple Application Definition","text":"<p>Work in progress</p> <p>This part of the documentation is still being written and it might be confusing or incomplete.</p> <p>Concept of this How-to:</p> <p>Create an example file NXdouble_slit</p> <p>NXslit_experiments --&gt; NXdouble_slit NXslit_experiments --&gt; NXsingle_slit</p> <p>They should learn the basic principles of how nexus works, the different path notations - Principles of nexus     - concepts     - appdefs     - base classes - Inheritance of application definitions and base classes - Connection of concept paths and instance paths - Description of appdef/base class notation (upper and lower case) - Basic tools for creation (pynxtools) and verification (pynxtools?) of nexus files</p> <p>Additional information (i.e., not in this tutorial but linked to this): - Creating a reader in pynxtools - Reading/writing nexus data in nomad</p>"},{"location":"learn/multiple-appdefs.html","title":"Multiple Application Definitions in NeXus","text":"<p>Work in progress</p> <p>This part of the documentation is still being written and it might be confusing or incomplete.</p> <p>This tutorial showcases how to employ multiple application definitions in NeXus for creating a file that conforms to various definitions simultaneously.</p> <p>Prerequisites</p> <p>Familiarity with the basics of NeXus and its application definitions is required. For an introduction to NeXus, please refer to the basic documentation.</p> <p>In a laboratory setting, the data we collect can vary significantly depending on the experiment's specific setup. Consider, for instance, an experiment characterized using the <code>NXexperiment</code> application definition. Suppose we want to enhance this experiment by incorporating energy resolution details. A straightforward approach might involve creating a specialized sub-application definition, like <code>NXexperiment_energy_resolved</code>, to include metadata about the experiment's energy resolution.</p> <p>While this method is effective for initial expansions of the metadata, it becomes cumbersome when trying to merge multiple enhancements into a single application definition. Imagine we wish to integrate additional elements that provide time resolution data for our experiment.  We need to create three sub application definitions to reflect all combinations: <code>NXexperiment_time_resolved</code>, <code>NXexperiment_energy_resolved</code> and <code>NXexperiment_energy_time_resolved</code>. For three experimental facets we already need 7 sub application definitions. An additional problem is that we have to repeat the whole procedure for all experiments we like to add the specific traits to. So if we have three different parent application definitions we already need to create 9 sub application definitions just to add energy and time resolution.</p> <p>The solution for this problem is to specify multiple application definitions while writing a NeXus file to follow different traits of the experiment. This allows us to simply create <code>NXtime_resolved</code> and <code>NXenergy_resolved</code> and combine it with any experiment we want to use it with. This comes, however, with a few drawbacks. One of them is that it is currently not possible to write a file which wants to use two different application definitions which have conflicting fields. While this is generally possible in the framework of NeXus, since every application definition creates their own namespace, this is not supported when the paths are reduced to entry path notation.</p> <p>ToDo: - Make an example of NXexperiment, NXtime_resolved and NXenergy_resolved and show how it is combined into the instance path. - Also show this for a conflict. Compare concept path (no problem) to instance path (colliding). - Write a part how it is described in the file that it follows two appdefs <code>/entry/definitions</code> as array containing both appdefs. - Explain that this is no problem with the expanded concept path notation but fails when we only use the instance path. - Explain the reader concept: One reader for one appdef, then pynxtools will figure out how to combine them (this is domain knowledge for the FAIRmat reader -&gt; will be different when a read/write tool is written somewhere else).</p>"},{"location":"learn/nexus-primer.html","title":"A primer on NeXus","text":"<p>Work in progress</p> <p>This part of the documentation is still being written and it might be confusing or incomplete.</p> <p>NeXus is is a description of a common data exchange format initially developed for neutron, X-ray, and muon experiments. Within FAIRmat we extensively extended the format to cover a range of experiments with major support for APM, ARPES, XPS, and optical spectroscpy but we also give advice and guidance for developing standards for other formats as well.</p> <p>NeXus as a tool for FAIR data</p> <p>NeXus is supported be the research data management platform NOMAD. Experimental data following an NeXus application definition can easily be uploaded and is recognized by NOMAD's search system. If you want to learn more about uploading NeXus data to NOMAD, please refer to the NeXus to nomad tutorial of this documentation. Accordingly, if you want to build data according to the FAIR principles, you can think of NeXus fulfilling the interoperability and reproducibility part and a research data management platform like NOMAD the findable and accessible part.</p>"},{"location":"learn/nexus-primer.html#what-is-nexus","title":"What is NeXus?","text":"<p>Sometimes, NeXus is seen as writing data to some form of file in hdf5 format. While this is partly true, NeXus is independent of the actual storage format but is typically written into an hdf5 file.</p> <p>But what is NeXus then? It is the conceptual layer above the file structure. It is a contract on which data has to be present and how to name them in a given dataset. Hence, using NeXus participates in making data FAIR. It especially covers the interoperability and reproducibility part of research data.</p> <p>NeXus path notations</p> <p>There are several methods for referencing concepts or data paths within NeXus:</p> <ul> <li> <p>Concept Path Notation: This notation describes the hierarchical structure of NeXus concepts using class names. For example, <code>NXexperiment:/NXentry/NXinstrument/NXdetector</code> indicates the creation of a new NXdetector class within the NXexperiment concept. This path typically forms automatically when an application definition extends a base class's fields.</p> </li> <li> <p>Instance Path Notation: It represents the actual location of a field or group in a NeXus data instance (e.g., an HDF5 file). An example is <code>my_file.nxs:/entry/instrument/detector</code>.</p> </li> <li> <p>Combined Notation: This combines concept and instance paths. For example, <code>NXexperiment:/NXentry[my_file.nxs:entry]/NXinstrument[instrument]/NXdetector[detector]</code>. Here, concept paths are outside and instance paths within square brackets. The leftmost entries may include the NeXus class or file reference.</p> </li> <li> <p>Appdef Notation: This format is used in application definitions, where uppercase indicates a selectable name and lowercase a fixed name. Examples include <code>NXexperiment:ENTRY[my_experiment.nxs:entry]/INSTRUMENT[instrument]/DETECTOR[detector]</code> and <code>NXexperiment:ENTRY[my_experiment.nxs:entry]/my_INSTRUMENT[my_instrument]/DETECTOR[detector]</code>.</p> </li> </ul>"},{"location":"reference/definitions.html","title":"NeXus definitions","text":"<p>We link two references here. The first links to the official definitions by the NIAC and the second one links to latest FAIRmat definitions.</p> <ul> <li>Official NIAC definitions</li> <li>Latest FAIRmat definitions</li> </ul> <p>The FAIRmat definitions are regularly contributed to NIAC (around every 6 months) but generally reflect a state which is still under development and may contain new or improved application definitions or base classes. Consider it as the public review stage of these application definitions. However, there might be some parts which are still under discussion and will be subject to change.</p>"},{"location":"reference/plugins.html","title":"Plugins","text":"<p>There are a number of plugins available for pynxtools that are maintained within FAIRmat. These are extensions of pynxtools used for reading data of specific experimental techniques.</p> <ul> <li>pynxtools-mpes: A reader for multi-dimensional photoelectron spectroscopy data.</li> <li>pynxtools-stm: A reader for scanning tunneling microscopy (SPM) and spectroscopy (STS) data.</li> <li>pynxtools-xps: A reader for X-ray photoelectron spectroscopy (XPS) data. Documentation can be found here.</li> <li>pynxtools-apm: A reader for atom probe as well as related field ion microscopy data. Documentation can be found here.</li> <li>pynxtools-em: A reader for electron microscopy data. Documentation can be found here.</li> <li>pynxtools-ellips: A reader for ellipsometry data. Documentation can be found here.</li> </ul>"},{"location":"reference/plugins.html#installation","title":"Installation","text":"<p>You can install each of the plugins together with pynxtools by passing the name of the plugin as an extra to the pip install call. For example, for the pynxtools-mpes plugin:</p> <pre><code>pip install pynxtools[mpes]\n</code></pre> <p>In addition, you can also install all of the pynxtools reader plugins which are maintained by FAIRmat by passing the [convert] extra to the pip install call:</p> <pre><code>pip install pynxtools[convert]\n</code></pre> <p>There is also a cookiecutter template available for creating your own pynxtools plugin.</p>"},{"location":"tutorial/converting-data-to-nexus.html","title":"Converting research data to NeXus","text":""},{"location":"tutorial/converting-data-to-nexus.html#who-is-this-tutorial-for","title":"Who is this tutorial for?","text":"<p>The document is for people who want to standardize their research data by converting their research data into a NeXus standardized format. We cover the basic principles and common principles of NeXus, here. For a more detailed description on the general principles of NeXus we recommend reading our learning page for NeXus or the official NeXus user manual.</p>"},{"location":"tutorial/converting-data-to-nexus.html#what-should-you-should-know-before-this-tutorial","title":"What should you should know before this tutorial?","text":"<ul> <li>You should have a basic understanding of NeXus - A primer on NeXus</li> <li>You should have a basic understanding of FAIR data</li> </ul>"},{"location":"tutorial/converting-data-to-nexus.html#what-you-will-know-at-the-end-of-this-tutorial","title":"What you will know at the end of this tutorial?","text":"<p>You will have</p> <ul> <li>a basic understanding how to use the NeXus data converter from the pynxtools package</li> </ul>"},{"location":"tutorial/converting-data-to-nexus.html#setup","title":"Setup","text":"<p>We use a Python tool to make converting our research data easier. This has a number of readers that support multiple file formats. You can browse the separate folders to find the reader that might work for you. A generic reader is the JSON Map Reader. In addition, we provide multiple reader plugins for different experimental techniques.</p> <p>We will use the XPS reader plugin with a SpecsLabProdigy file (file extension: .sle) as an example.</p>"},{"location":"tutorial/converting-data-to-nexus.html#steps","title":"Steps","text":"<ol> <li>Download the example files from here: Example files</li> <li>Extract the zip and copy the files in your current working directory. You can find the working directory by typing the following in your terminal: <pre><code>pwd\n</code></pre></li> <li>Install pynxtools with the XPS reader plugin: <pre><code>pip install pynxtools[xps]\n</code></pre></li> <li>Verify you can run the <code>dataconverter</code> in a terminal window. Open a terminal with the Python environment where you installed <code>pynxtools</code>. Then type the following: <pre><code>dataconverter --help\n</code></pre></li> </ol>"},{"location":"tutorial/converting-data-to-nexus.html#converting-the-example-files","title":"Converting the example files","text":"<p>Once you have your files copied into the working directory, your directory structure should look like this: <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 EX439_S718_Au.sle\n\u251c\u2500\u2500 eln_data_sle.yaml\n\u2514\u2500\u2500 params.yaml\n</code></pre></p> <p>The <code>eln_data_sle.yaml</code> YAML file is another data file containing additional information (e.g., information about the experimentator) that is not provided in the main data file.</p> <p>Next, you will run the conversion routine from your Python environment: <pre><code>dataconverter --params-file params.yaml\n</code></pre></p> <p>Here we use a <code>params.yaml</code> parameter file to configure the converter.  This will create a file called <code>Au_25_mbar_O2_no_align.nxs</code> in your current directory.</p> <p>Congrats! You now have a FAIR NeXus file!</p> <p>You can try out other examples from pynxtools.</p>"},{"location":"tutorial/nexus-to-nomad.html","title":"Uploading NeXus files to NOMAD","text":"<p>Great choice! Nomad makes it easier than ever to work with your research data. At this point you are probably have an idea of what FAIR data is. Even if you don't, it doesn't matter. Nomad provides a simple graphical interface that let's you collect and have your data ready for publication.</p> <p>In this tutorial, we will go through how one can upload their NeXus files to Nomad.</p> <p>Nomad, as a FAIR data platform, supports NeXus and allows users to upload their NeXus (.nxs) files directly. These files get interpreted and added to your Nomad account with complete control on how you would like to present and publish them alongside your research.</p>"},{"location":"tutorial/nexus-to-nomad.html#create-an-account","title":"Create an account","text":"<p>The very first thing you need to do is get a Nomad account. If you don't have one you can register here.</p> <ol> <li>Navigate to nomad-lab.eu</li> <li>Click on <code>Login / Register</code> on the top right corner.</li> </ol> <p></p>"},{"location":"tutorial/nexus-to-nomad.html#create-an-upload","title":"Create an Upload","text":"<p>Nomad allows you to have a draft working space called an upload. This allows you to test and prepare how your data will look in Nomad before you publish it.</p> <p>Go to <code>Publish -&gt; Uploads</code></p> <p></p> <p></p> <p>Click <code>Create a new upload</code></p> <p></p>"},{"location":"tutorial/nexus-to-nomad.html#upload-your-nexus-file","title":"Upload your NeXus file","text":"<p>Now we can upload your FAIR NeXus file and let Nomad interpret it for us.</p> <p>Click the <code>Drop files here...</code> button and choose your NeXus file from your device. </p> <p>Once Nomad has interpreted your data, this is what your screen will look like.</p> <p></p>"},{"location":"tutorial/nexus-to-nomad.html#browsing-your-nexus-data","title":"Browsing your NeXus data","text":"<p>You can find the Nomad interpretation of your data under entries. If you click on this arrow, you will be able to see an Overview of your NeXus file.</p> <p></p> <p></p> <p>On the Overview page you will be presented with <code>H5Web</code> that let's you browse the data in your <code>NeXus</code> file directly.</p> <p></p> <p></p> <p>Nomad also interprets and <code>normalizes</code> this data to make it interoperable with other corners of Material's research. To browse this <code>normalized</code> data you can browse the <code>DATA</code> tab. Here you see all the information Nomad has picked up and made available for search and comparison with synthesis, experimental, and computational materials data.</p> <p></p> <p>Feel free to explore more!</p>"}]}